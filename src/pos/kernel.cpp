// Copyright (c) 2012-2013 The PPCoin developers
// Copyright (c) 2020 The Bitcones developers
// Distributed under the MIT/X11 software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include <boost/assign/list_of.hpp>
#include <boost/lexical_cast.hpp>

#include <chainparams.h>
#include <db.h>
#include <init.h>
#include <pos/kernel.h>
#include <pos/blocksigner.h>
#include <policy/policy.h>
#include <script/interpreter.h>
#include <timedata.h>
#include <util/system.h>
#include <util/time.h>
#include <validation.h>
#include <wallet/wallet.h>

#include <numeric>

using namespace std;

// Hard checkpoints of stake modifiers to ensure they are deterministic
static std::map<int, unsigned int> mapStakeModifierCheckpoints = boost::assign::map_list_of(0, 0xfd11f4e7);

// Get time weight
int64_t GetWeight(int64_t nIntervalBeginning, int64_t nIntervalEnd)
{
    return nIntervalEnd - nIntervalBeginning - Params().GetConsensus().nStakeMinAge;
}



// Stake Modifier (hash modifier of proof-of-stake):
// The purpose of stake modifier is to prevent a txout (coin) owner from
// computing future proof-of-stake generated by this txout at the time
// of transaction confirmation. To meet kernel protocol, the txout
// must hash with a future stake modifier to generate the proof.
// Stake modifier consists of bits each of which is contributed from a
// selected block of a given block group in the past.
// The selection of a block is based on a hash of the block's proof-hash and
// the previous stake modifier.
// Stake modifier is recomputed at a fixed time interval instead of every
// block. This is to make it difficult for an attacker to gain control of
// additional bits in the stake modifier, even after generating a chain of
// blocks.
//bool ComputeNextStakeModifier(const CBlockIndex* pindexCurrent, uint256& nStakeModifier, bool& fGeneratedStakeModifier)
//{
//    const Consensus::Params& params = Params().GetConsensus();
//    const CBlockIndex* pindexPrev = pindexCurrent->pprev;
//    nStakeModifier = uint256();
//    fGeneratedStakeModifier = false;
//    if (!pindexPrev) {
//        fGeneratedStakeModifier = true;
//        return true; // genesis block's modifier is 0
//    }
//    // First find current stake modifier and its generation block time
//    // if it's not old enough, return the same stake modifier
//    int64_t nModifierTime = 0;
//    if (!GetLastStakeModifier(pindexPrev, nStakeModifier, nModifierTime))
//        return error("ComputeNextStakeModifier: unable to get last modifier");
//    LogPrint(BCLog::POS, "%s: prev modifier=0x%016x time=%s epoch=%u\n", __func__, nStakeModifier, DateTimeStrFormat("%Y-%m-%d %H:%M:%S", nModifierTime).c_str(), (unsigned int)nModifierTime);
//    if (nModifierTime / params.nModifierInterval >= pindexPrev->GetBlockTime() / params.nModifierInterval)
//        return true;
//
//    // Sort candidate blocks by timestamp
//    vector<pair<int64_t, uint256>> vSortedByTimestamp;
//    vSortedByTimestamp.reserve(64 * params.nModifierInterval / params.nPosTargetSpacing);
//    int64_t nSelectionInterval = GetStakeModifierSelectionInterval();
//    int64_t nSelectionIntervalStart = (pindexPrev->GetBlockTime() / params.nModifierInterval) * params.nModifierInterval - nSelectionInterval;
//    const CBlockIndex* pindex = pindexPrev;
//    while (pindex && pindex->GetBlockTime() >= nSelectionIntervalStart) {
//        vSortedByTimestamp.push_back(make_pair(pindex->GetBlockTime(), pindex->GetBlockHash()));
//        pindex = pindex->pprev;
//    }
//    int nHeightFirstCandidate = pindex ? (pindex->nHeight + 1) : 0;
//    reverse(vSortedByTimestamp.begin(), vSortedByTimestamp.end());
//    sort(vSortedByTimestamp.begin(), vSortedByTimestamp.end());
//
//    // Select 64 blocks from candidate blocks to generate stake modifier
//    uint64_t nStakeModifierNew = 0;
//    int64_t nSelectionIntervalStop = nSelectionIntervalStart;
//    map<uint256, const CBlockIndex*> mapSelectedBlocks;
//    for (int nRound = 0; nRound < min(64, (int)vSortedByTimestamp.size()); nRound++) {
//        // add an interval section to the current selection round
//        nSelectionIntervalStop += GetStakeModifierSelectionIntervalSection(nRound);
//        // select a block from the candidates of current round
//        if (!SelectBlockFromCandidates(vSortedByTimestamp, mapSelectedBlocks, nSelectionIntervalStop, nStakeModifier, &pindex))
//            return error("ComputeNextStakeModifier: unable to select block at round %d", nRound);
//        // write the entropy bit of the selected block
//        nStakeModifierNew |= (((uint64_t)pindex->GetStakeEntropyBit()) << nRound);
//        // add the selected block from candidates to selected list
//        mapSelectedBlocks.insert(make_pair(pindex->GetBlockHash(), pindex));
//        LogPrint(BCLog::POS, "%s : selected round %d stop=%s height=%d bit=%d\n", __func__, nRound, DateTimeStrFormat("%Y-%m-%d %H:%M:%S", nSelectionIntervalStop).c_str(), pindex->nHeight, pindex->GetStakeEntropyBit());
//    }
//
//    // Print selection map for visualization of the selected blocks
//    if (gArgs.GetBoolArg("-debug", false) && gArgs.GetBoolArg("-printstakemodifier", false)) {
//        string strSelectionMap = "";
//        // '-' indicates proof-of-work blocks not selected
//        strSelectionMap.insert(0, pindexPrev->nHeight - nHeightFirstCandidate + 1, '-');
//        pindex = pindexPrev;
//        while (pindex && pindex->nHeight >= nHeightFirstCandidate) {
//            // '=' indicates proof-of-stake blocks not selected
//            if (pindex->IsProofOfStake())
//                strSelectionMap.replace(pindex->nHeight - nHeightFirstCandidate, 1, "=");
//            pindex = pindex->pprev;
//        }
//        for (const auto& item : mapSelectedBlocks) {
//            // 'S' indicates selected proof-of-stake blocks
//            // 'W' indicates selected proof-of-work blocks
//            strSelectionMap.replace(item.second->nHeight - nHeightFirstCandidate, 1, item.second->IsProofOfStake() ? "S" : "W");
//        }
//        LogPrint(BCLog::POS, "%s: selection height [%d, %d] map %s\n", __func__, nHeightFirstCandidate, pindexPrev->nHeight, strSelectionMap);
//    }
//    LogPrint(BCLog::POS, "%s: new modifier=0x%016x time=%s\n", __func__, nStakeModifierNew, DateTimeStrFormat("%Y-%m-%d %H:%M:%S", pindexPrev->GetBlockTime()).c_str());
//
//    nStakeModifier = nStakeModifierNew;
//    fGeneratedStakeModifier = true;
//    return true;
//}
uint256 ComputeNextStakeModifier(const CBlockIndex* pindexPrev, const uint256 kernel, bool& fGeneratedStakeModifier)
{
    auto prevStakeModifier = pindexPrev->nStakeModifier;
    if (pindexPrev->nHeight == 2107198 || pindexPrev->nHeight == FORK_HEIGHT)
    {
        return uint256();
    }
    else {
        CDataStream ss(SER_GETHASH, 0);
        ss << kernel << prevStakeModifier;
        return Hash(ss.begin(), ss.end());
    }
}

static bool GetKernelStakeModifier(uint256& nStakeModifier, int& nStakeModifierHeight, int64_t& nStakeModifierTime, bool fPrintProofOfStake)
{
    //prevStakeModifier = pindexPrev->nStakeModifier;
    CBlockIndex* pindexPrev = ::ChainActive().Tip();
    nStakeModifier = pindexPrev->nStakeModifier;
    return true;
}

//static bool GetKernelStakeModifier(uint256 hashBlockFrom, unsigned int nTimeTx, uint64_t& nStakeModifier, int& nStakeModifierHeight, int64_t& nStakeModifierTime, bool fPrintProofOfStake)
//{
//    nStakeModifier = 0;
//    if (!::BlockIndex().count(hashBlockFrom))
//        return error("GetKernelStakeModifier() : block not indexed");
//
//    const CBlockIndex* pindexFrom = ::BlockIndex()[hashBlockFrom];
//    nStakeModifierHeight = pindexFrom->nHeight;
//    nStakeModifierTime = pindexFrom->GetBlockTime();
//    int64_t nStakeModifierSelectionInterval = GetStakeModifierSelectionInterval();
//    const CBlockIndex* pindex = pindexFrom;
//    //CBlockIndex* pindexNext = ::ChainActive()[pindexFrom->nHeight + 1];
//    CBlockIndex* pindexNext = ::ChainActive().Next(pindexFrom);
//
//    // loop to find the stake modifier later by a selection interval
//    while (nStakeModifierTime < pindexFrom->GetBlockTime() + nStakeModifierSelectionInterval) {
//        if (!pindexNext) {
//            return error("GetKernelStakeModifier() : pindexnext not found %d", nStakeModifier);
//            nStakeModifier = 0;
//            // return error("GetKernelStakeModifier() : pindexnext not found");
//        }
//        pindex = pindexNext;
//        //pindexNext = ::ChainActive()[pindexNext->nHeight + 1];
//        pindexNext = ::ChainActive().Next(pindexFrom);
//        if (pindex->GeneratedStakeModifier()) {
//            nStakeModifierHeight = pindex->nHeight;
//            nStakeModifierTime = pindex->GetBlockTime();
//        }
//    }
//    nStakeModifier = pindex->nStakeModifier;
//    return true;
//}

bool hasStakeMinDepth(int contextHeight, int utxoFromBlockHeight, int& nDepthFound)
{
    const int minHistoryRequired = Params().GetConsensus().nMinStakeHistory;
    return ((contextHeight - utxoFromBlockHeight) >= minHistoryRequired);
}

int getLastHeight(uint256 txHash)
{
    uint256 hashBlock;
    CTransactionRef stakeInput;
    if (!GetTransaction(txHash, stakeInput, Params().GetConsensus(), hashBlock) || hashBlock == uint256())
        return 0;

    return ::BlockIndex()[hashBlock]->nHeight;
}

bool CheckStakeKernelHash(const CBlockIndex* pindexPrev, unsigned int nBits, const CBlock& blockFrom, unsigned int nTxPrevOffset, const CTransactionRef& txPrev, const COutPoint& prevout, unsigned int nTimeTx, uint256& hashProofOfStake, bool fMinting, bool fValidate)
{
    //return true;
    auto txPrevTime = blockFrom.GetBlockTime();
    if (nTimeTx < txPrevTime) // Transaction timestamp violation
        return error("CheckStakeKernelHash() : nTime violation");

    auto nStakeMinAge = Params().GetConsensus().nStakeMinAge;

    int nHeight = pindexPrev->nHeight + 1;

    unsigned int nTimeBlockFrom = blockFrom.GetBlockTime();
    if (nTimeBlockFrom + nStakeMinAge > nTimeTx) // Min age requirement
        return error("CheckStakeKernelHash() : min age violation");

    arith_uint256 bnTargetStake;
    bnTargetStake.SetCompact(nBits);
    CAmount nValueIn = txPrev->vout[prevout.n].nValue;

    arith_uint256 bnCoinDayWeight = nValueIn / 100;
    bnTargetStake *= bnCoinDayWeight;

    const CAmount minStakeAmount = Params().GetConsensus().nMinStakeAmount;
    if (nValueIn < minStakeAmount && nHeight > Params().GetConsensus().nForkHeightMinStakeAmount)
        return error("CheckStakeKernelHash() : min stake amount not met");

    // Calculate hash
    CDataStream ss(SER_GETHASH, 0);
    uint256 nStakeModifier = pindexPrev->nStakeModifier;
    int nStakeModifierHeight = 0;
    int64_t nStakeModifierTime = 0;

    //if (!GetKernelStakeModifier(nStakeModifier, nStakeModifierHeight, nStakeModifierTime, false))
      //  return error("CheckStakeKernelHash() : modifier failed");
    ss << nStakeModifier;
    ss << nTimeBlockFrom << prevout.n << txPrev->GetHash() << nTimeTx;
    //ss << nTimeBlockFrom << nTxPrevOffset << txPrevTime << prevout.n << nTimeTx;
    // ss<< nStakeModifier << nTimeBlockfrom << txPrev.n << txPrev.GetHash << nTimeTx;
    hashProofOfStake = Hash(ss.begin(), ss.end());

    if (hashProofOfStake == uint256())
        return false;

    // Now check if proof-of-stake hash meets target protocol
    if (UintToArith256(hashProofOfStake) > bnTargetStake)
        return false;

    return true;
}

bool CheckKernelScript(CScript scriptVin, CScript scriptVout)
{
    auto extractKeyID = [](CScript scriptPubKey) {

        CKeyID keyID;
        std::vector<std::vector<unsigned char>> vSolutions;
        txnouttype whichType = Solver(scriptPubKey, vSolutions);
        {
            if (whichType == TX_PUBKEYHASH) {
                keyID = CKeyID(uint160(vSolutions[0]));
            } else if (whichType == TX_PUBKEY) {
                keyID = CPubKey(vSolutions[0]).GetID();
            }
        }

        return keyID;
    };

    return extractKeyID(scriptVin) == extractKeyID(scriptVout);
}

// Check kernel hash target and coinstake signature
bool CheckProofOfStake(const CBlock& block, uint256& hashProofOfStake, const CBlockIndex* pindexPrev)
{
    if(pindexPrev->nHeight < FORK_HEIGHT){
        return true;
    }
    const CTransactionRef& tx = block.vtx[1];
    if (!tx->IsCoinStake())
        return error("CheckProofOfStake() : called on non-coinstake %s", tx->GetHash().ToString().c_str());

    // Kernel (input 0) must match the stake hash target per coin age (nBits)
    const CTxIn& txin = tx->vin[0];

    // First try finding the previous transaction in database
    uint256 hashBlock;
    CTransactionRef txPrev;
    const auto& cons = Params().GetConsensus();
    if (!GetTransaction(txin.prevout.hash, txPrev, cons, hashBlock))
        return error("CheckProofOfStake() : INFO: read txPrev failed");

    CTxOut prevTxOut = txPrev->vout[txin.prevout.n];
    CBlockIndex* pindex = NULL;
    BlockMap::iterator it = ::BlockIndex().find(hashBlock);
    if (it != ::BlockIndex().end())
        pindex = it->second;
    else
        return error("CheckProofOfStake() : read block failed");

    //! retrieve height where utxo originates
    const int nPreviousBlockHeight = pindexPrev->nHeight + 1;
    const int nBlockFromHeight = getLastHeight(txin.prevout.hash);
    if (!nBlockFromHeight) {
        return false;
    }

    //! test if depth minimum is met
    int nDepthFound = 0;
    if (!hasStakeMinDepth(nPreviousBlockHeight, nBlockFromHeight, nDepthFound))
        return error("CheckProofOfStake() : min stake depth not met (need: %d found: %d)", Params().GetConsensus().nMinStakeHistory, nDepthFound);

    // Read block header
    CBlock blockprev;
    if (!ReadBlockFromDisk(blockprev, pindex->GetBlockPos(), cons))
        return error("CheckProofOfStake(): INFO: failed to find block");

    if (!CheckKernelScript(prevTxOut.scriptPubKey, tx->vout[1].scriptPubKey))
        return error("CheckProofOfStake() : INFO: check kernel script failed on coinstake %s, hashProof=%s \n", tx->GetHash().ToString().c_str(), hashProofOfStake.ToString().c_str());

    unsigned int nTime = block.nTime;
    if (!CheckStakeKernelHash(pindexPrev, block.nBits, blockprev, sizeof(CBlock), txPrev, txin.prevout, nTime, hashProofOfStake, false, true))
        return error("CheckProofOfStake() : INFO: check kernel failed on coinstake %s, hashProof=%s \n", tx->GetHash().ToString().c_str(), hashProofOfStake.ToString().c_str()); // may occur during initial download or if behind on block chain sync

    return true;
}

// Get stake modifier checksum
unsigned int GetStakeModifierChecksum(const CBlockIndex* pindex)
{
    assert(pindex->pprev || pindex->GetBlockHash() == Params().GetConsensus().hashGenesisBlock);
    // Hash previous checksum with flags, hashProofOfStake and nStakeModifier
    CDataStream ss(SER_GETHASH, 0);
    if (pindex->pprev)
        ss << pindex->pprev->nStakeModifierChecksum;
    ss << pindex->nFlags << pindex->hashProofOfStake << pindex->nStakeModifier;
    arith_uint256 hashChecksum = UintToArith256(Hash(ss.begin(), ss.end()));
    hashChecksum >>= (256 - 32);
    return hashChecksum.GetLow64();
}

// Check stake modifier hard checkpoints
bool CheckStakeModifierCheckpoints(int nHeight, unsigned int nStakeModifierChecksum)
{
    if (mapStakeModifierCheckpoints.count(nHeight))
        return nStakeModifierChecksum == mapStakeModifierCheckpoints[nHeight];
    return true;
}
